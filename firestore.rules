
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // User profiles: users can read/write their own profile if email is verified.
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId && request.auth.token.email_verified == true;
      // Consider adding admin read access if needed via a custom claim or roles collection.
    }

    // Forms:
    match /forms/{formId} {
      function isOwner() {
        return request.auth != null && resource.data.ownerId == request.auth.uid;
      }
      // Placeholder for editor role - you'd populate this array in your app
      function isEditor() {
        return request.auth != null && resource.data.editors is list && request.auth.uid in resource.data.editors;
      }
      // Placeholder for viewer role
      function isViewer() {
         return request.auth != null && resource.data.viewers is list && request.auth.uid in resource.data.viewers;
      }

      function canEdit() {
        return request.auth != null && request.auth.token.email_verified == true && (isOwner() || isEditor());
      }

      function canView() {
        // Public forms can be read by anyone (even unauthenticated)
        if (resource.data.isPublic == true) {
          return true;
        }
        // Authenticated, verified users can view if they are owner, editor, or viewer
        return request.auth != null && request.auth.token.email_verified == true && (isOwner() || isEditor() || isViewer());
      }

      allow read: if canView();

      allow create: if request.auth != null && request.auth.token.email_verified == true
                    && request.resource.data.ownerId == request.auth.uid
                    && 'title' in request.resource.data && request.resource.data.title is string && request.resource.data.title.size() > 0
                    && 'intendedUseCase' in request.resource.data && request.resource.data.intendedUseCase is string && request.resource.data.intendedUseCase.size() > 0
                    && 'formConfiguration' in request.resource.data && request.resource.data.formConfiguration is string
                    && 'status' in request.resource.data && request.resource.data.status in ['Draft', 'Published', 'Archived']
                    && 'submissionsCount' in request.resource.data && request.resource.data.submissionsCount == 0
                    && 'isPublic' in request.resource.data && request.resource.data.isPublic is bool
                    && 'tags' in request.resource.data && request.resource.data.tags is list
                    && request.resource.data.lastModified == request.time
                    && request.resource.data.createdAt == request.time;

      allow update: if canEdit()
                    && !(request.resource.data.ownerId != resource.data.ownerId) // ownerId cannot change
                    && !(request.resource.data.createdAt != resource.data.createdAt) // createdAt cannot change
                    && 'title' in request.resource.data && request.resource.data.title is string && request.resource.data.title.size() > 0
                    && 'intendedUseCase' in request.resource.data && request.resource.data.intendedUseCase is string && request.resource.data.intendedUseCase.size() > 0
                    && 'formConfiguration' in request.resource.data && request.resource.data.formConfiguration is string
                    && 'status' in request.resource.data && request.resource.data.status in ['Draft', 'Published', 'Archived']
                    && 'isPublic' in request.resource.data && request.resource.data.isPublic is bool  // Allow updating isPublic
                    && 'tags' in request.resource.data && request.resource.data.tags is list     // Allow updating tags
                    && request.resource.data.lastModified == request.time;
                    // submissionsCount should be updated by a backend function, not directly by client

      allow delete: if request.auth != null && request.auth.token.email_verified == true && isOwner();

      // Submissions for a form
      match /submissions/{submissionId} {
        function canSubmitToForm() {
          let form = get(/databases/$(database)/documents/forms/$(formId)).data;
          // Anyone can submit to a published public form
          if (form.isPublic == true && form.status == 'Published') {
            return true;
          }
          // Authenticated, verified users can submit if they can view and form is published
          if (request.auth != null && request.auth.token.email_verified == true &&
              form.status == 'Published' &&
              (form.ownerId == request.auth.uid ||
               (form.viewers is list && request.auth.uid in form.viewers) ||
               (form.editors is list && request.auth.uid in form.editors)
              )
             ) {
            return true;
          }
          return false;
        }

        allow create: if canSubmitToForm()
                      && 'formId' in request.resource.data && request.resource.data.formId == formId
                      && 'submitterId' in request.resource.data // Can be UID or 'anonymous'
                      && 'submissionDate' in request.resource.data && request.resource.data.submissionDate == request.time
                      && 'data' in request.resource.data && request.resource.data.data is map;

        allow read: if request.auth != null && request.auth.token.email_verified == true &&
                       (get(/databases/$(database)/documents/forms/$(formId)).data.ownerId == request.auth.uid ||
                        (get(/databases/$(database)/documents/forms/$(formId)).data.editors is list && request.auth.uid in get(/databases/$(database)/documents/forms/$(formId)).data.editors)
                       );
                       // Add if submitter can read their own: || request.auth.uid == resource.data.submitterId;

        allow update, delete: if false; // Submissions are generally immutable
      }
    }

    // Top-level Submissions collection (if used, ensure security matches form permissions)
    // This example assumes submissions are primarily accessed via form subcollections for stricter rules.
    // If using a top-level collection, you'd need to duplicate form permission checks or denormalize formOwnerId.
    match /submissions/{submissionId} {
      allow read: if request.auth != null && request.auth.token.email_verified == true && resource.data.formOwnerId == request.auth.uid; // Example if formOwnerId is denormalized
      allow create, update, delete: if false; // Handled by subcollection rules or backend logic
    }
  }
}
